
%из файла полученного от робота вытащим в массив
%и разобьем каждый столбец на переменные
dt = 0.1;
inputDataRob = dlmread('D:\UMRU\lab4\UtkinVolosh_lab4_brig1.txt');
t = inputDataRob(:,1);
omega_1 = inputDataRob(:,2);
omega_2= inputDataRob(:,3);
omega_3= inputDataRob(:,4);
omega_4= inputDataRob(:,5);
M1= inputDataRob(:,6);
M2= inputDataRob(:,7);
M3= inputDataRob(:,8);
M4= inputDataRob(:,9);
Vx_o= inputDataRob(:,10);
Vy_o= inputDataRob(:,11);
dpsi= inputDataRob(:,12);
x0= inputDataRob(:,13);
y0= inputDataRob(:,14);
psi = inputDataRob(:,15);
%откроем файл с данными по идеальным перемещениям
inputDataIdeal = dlmread('D:\UMRU\lab1\perfect_squareUV1.txt');
Xid = inputDataIdeal(:,1);
Yid = inputDataIdeal(:,2);
psi_id = inputDataIdeal(:,3);
%откроем файл с данными по идеальным скоростям
inputDataIdSpeed = dlmread('D:\UMRU\lab1\square.txt');
Vxid = inputDataIdSpeed(:,1);
Vyid = inputDataIdSpeed(:,2);
Omid = inputDataIdSpeed(:,3);
%Найдем рассогласование по скоростям

dVx = Vxid - Vx_o;
dVy = Vyid - Vy_o;
ddPsi = Omid - dpsi;

%Найдем ускорения
%Зададим начальные ускорения
ddVx(1) = 0;
ddVy(1) = 0;
ddOm(1) = 0;
%Найдем со второго элемента до конца 
for i =2 :1:length(dVx)
    ddVx(i,1) = (dVx(i,1)- dVx(i-1,1))/(dt);
    ddVy(i,1) = (dVy(i,1)- dVy(i-1,1))/(dt);
    ddOm(i,1) = (ddPsi(i,1)- ddPsi(i-1,1))/(dt);
end

%Получаем паразитные ускорения в связанной системе координат

%проанализирововав конечные графики мы выясняем, что начальное ускорение не
%должно быть таким большим и таким отрицательным
%повелеваю 
ddVx(2,1) = 0.5;
%данное ускорение получено империческим путем
%получим  восставновленную траекторию движения по обратной связи 
for i =1 :1:length(dVx)
    xp(i,1) = 0;
    yp(i,1) = 0;
    psip(i,1) = 0;
end

Vxu(1,1) = Vxid(1,1);
Vyu(1,1) = Vyid(1,1);
Omu(1,1) = Omid(1,1);
for i =2 :1:length(dVx)
    Vxp(i,1) = Vxid(i,1)+ddVx(i,1)*dt;
    xp(i,1) = Vxp(i,1) *dt+xp(i-1,1);
    Vxu(i,1) = Vxid(i,1)+ (Vxid(i,1)-Vxp(i,1))+ (Xid(i,1)-xp(i,1))/dt;
    Vyp(i,1) = Vyid(i,1)+ddVy(i,1)*dt;
    yp(i,1) = Vyp(i,1) *dt+yp(i-1,1);
    Vyu(i,1) = Vyid(i,1)+ (Vyid(i,1)-Vyp(i,1))+ (Yid(i,1)-yp(i,1))/dt;
    Omp(i,1) = Omid(i,1)+ddOm(i,1)*dt;
    psip(i,1) = Omp(i,1) *dt+psip(i-1,1);
    Omu(i,1) = Omid(i,1)+ (Omid(i,1)-Omp(i,1))+ (psi_id(i,1)-psip(i,1))/dt;
end


%Зададим углол Psi
psiS(1,1) = 0;
for i =2 :1:length(dVx)
    psiS(i,1) = psiS(i-1,1) + Omp(i,1)*dt;
end

%Найдем VXp и VYp 
VXp = Vxp.*cos(psiS)-Vyp.*sin(psi);
VYp = Vxp.*sin(psiS)+Vyp.*cos(psi);

%Проинтегрируем полученные скорости для получения Xp и Yp - движения по
%заданной траектории
Xp(1) = 0;
Yp(1) = 0;
for i =2 :1:length(dVx)
    Xp(i,1) = Xp(i-1,1) + VXp(i,1)*dt;
    Yp(i,1) = Yp(i-1,1) + VYp(i,1)*dt;
end




%Найдем рассогласование по координатам по 
dX = Xid-Xp;
dY = Yid -Yp;
delPsi = psi_id - psiS;
dVx = Vxid - VXp;
dVy = Vyid - VYp;
ddPsi = Omid - dpsi;

%определим СКО и Мат.Ожидание для dX,dY,delPsi

%найдем среднее значение
dXsr = 0; dYsr = 0; delPsisr = 0;
for i = 1:1:length(dVx)
    dXsr = dXsr + dX(i);
    dYsr = dYsr + dY(i);
    delPsisr = delPsisr + delPsi(i);
end
%dXsr dYsr delPsisr так же будут матОжиданием
dXsr = dXsr/length(dVx); dYsr = dYsr/length(dVx); delPsisr = delPsisr/length(dVx); 

%найдем СКО 
dXsrSumm = 0; dYsrSumm = 0; delPsisrSumm = 0;
for i = 1:1:200
    dXsrSumm = dXsrSumm + (dX(i)-dXsr)^2;
    dYsrSumm = dYsrSumm + (dY(i)-dYsr)^2;
    delPsisrSumm = delPsisrSumm + (delPsi(i)-delPsisr)^2;
end

SKOdX = sqrt(dXsrSumm/199);
SKOdY = sqrt(dYsrSumm/199);
SKOdelPsi = sqrt(delPsisrSumm/199);


%определим СКО и Мат.Ожидание для dX_iv,dY_iv,delPsi_iv
%Найдем массивы dX_iv, dY_iv, delPsi_iv
dX_iv = Xid - Xvost;
dY_iv = Yid - Yvost;
delPsi_iv = psi_id - Psivost;
%найдем среднее значение
dXsr_iv = 0; dYsr_iv = 0; delPsisr_iv = 0;
for i = 1:1:length(dVx)
    dXsr_iv = dXsr_iv + dX_iv(i);
    dYsr_iv = dYsr_iv + dY_iv(i);
    delPsisr_iv = delPsisr_iv + delPsi_iv(i);
end
%dXsr dYsr delPsisr так же будут матОжиданием
dXsr_iv = dXsr_iv/200; dYsr_iv = dYsr_iv/200; delPsisr_iv = delPsisr_iv/200; 

%найдем СКО 
dXsrSumm_iv = 0; dYsrSumm_iv = 0; delPsisrSumm_iv = 0;
for i = 1:1:length(dVx)
    dXsrSumm_iv = dXsrSumm_iv + (dX_iv(i)-dXsr_iv)^2;
    dYsrSumm_iv = dYsrSumm_iv + (dY_iv(i)-dYsr_iv)^2;
    delPsisrSumm_iv = delPsisrSumm_iv + (delPsi_iv(i)-delPsisr_iv)^2;
end

SKOdX_iv = sqrt(dXsrSumm_iv/(length(dVx)-1));
SKOdY_iv = sqrt(dYsrSumm_iv/(length(dVx)-1));
SKOdelPsi_iv = sqrt(delPsisrSumm_iv/(length(dVx)-1));

%сравним СКО и МатОжидание, для они должны быть меньше 

abs(SKOdX_iv )< abs(SKOdX)
abs(SKOdY_iv )< abs(SKOdY)
abs(SKOdelPsi_iv) < abs(SKOdelPsi)
abs(dXsr_iv) < abs(dXsr)
abs(dYsr_iv )< abs(dYsr)
abs(delPsisr_iv) < abs(delPsisr)


plot(Xp,Yp)
grid on
hold on
plot(Xid,Yid)
plot(x0,y0)